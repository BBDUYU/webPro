<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive 3x3 루빅스 큐브</title>
<style>
body {
  margin: 0;
  height: 100vh;
  background: #111;
  display: flex;
  justify-content: center;
  align-items: center;
  perspective: 1000px;
  user-select: none;
  overflow: hidden;
  cursor: grab;
}

.cube-container {
  width: 300px;
  height: 300px;
  transform-style: preserve-3d;
  position: relative;
}

.cube {
  width: 300px;
  height: 300px;
  transform-style: preserve-3d;
  position: relative;
}

.cubelet {
  width: 90px;
  height: 90px;
  position: absolute;
  transform-style: preserve-3d;
  transition: transform 0.4s ease;
}

.face {
  width: 90px;
  height: 90px;
  position: absolute;
  border: 2px solid #000;
  box-sizing: border-box;
  backface-visibility: hidden;
}

.front  { background: red;    transform: translateZ(45px); }
.back   { background: orange; transform: rotateY(180deg) translateZ(45px); }
.right  { background: blue;   transform: rotateY(90deg) translateZ(45px); }
.left   { background: green;  transform: rotateY(-90deg) translateZ(45px); }
.top    { background: white;  transform: rotateX(90deg) translateZ(45px); }
.bottom { background: yellow; transform: rotateX(-90deg) translateZ(45px); }
</style>
</head>
<body>
<div class="cube-container" id="container">
  <div class="cube" id="cube"></div>
</div>

<script>
const cube = document.getElementById("cube");
const container = document.getElementById("container");
const size = 3;
const spacing = 100;
const cubelets = [];

// 큐브렛 생성
for(let x=0;x<size;x++){
  for(let y=0;y<size;y++){
    for(let z=0;z<size;z++){
      const div = document.createElement("div");
      div.classList.add("cubelet");
      div.dataset.x = x;
      div.dataset.y = y;
      div.dataset.z = z;

      const px = (x-1)*spacing;
      const py = (y-1)*spacing;
      const pz = (z-1)*spacing;
      div.style.transform = `translate3d(${px}px, ${py}px, ${pz}px)`;

      ["front","back","left","right","top","bottom"].forEach(f=>{
        const face = document.createElement("div");
        face.classList.add("face",f);
        div.appendChild(face);
      });

      cube.appendChild(div);
      cubelets.push(div);
    }
  }
}

// 회전 함수
function rotateLayer(axis,index,dir=1){
  cubelets.forEach(c=>{
    if(axis==="x" && c.dataset.x==index ||
       axis==="y" && c.dataset.y==index ||
       axis==="z" && c.dataset.z==index){
      const style = c.style.transform;
      const regex = /translate3d\(([^)]*)\)/;
      const match = style.match(regex);
      const trans = match ? match[1] : "0px,0px,0px";
      let rot;
      if(axis==="x") rot=`rotateX(${90*dir}deg) `;
      if(axis==="y") rot=`rotateY(${90*dir}deg) `;
      if(axis==="z") rot=`rotateZ(${90*dir}deg) `;
      c.style.transform = rot + `translate3d(${trans})`;
    }
  });
}

// 전체 큐브 회전
let isDragging=false;
let dragMode="cube"; // cube or layer
let startX=0, startY=0;
let rotX=0, rotY=0;
let selectedLayer = null;

function startDrag(e){
  isDragging = true;
  startX = e.clientX || e.touches[0].clientX;
  startY = e.clientY || e.touches[0].clientY;

  // 클릭한 큐브렛 감지
  const rect = cube.getBoundingClientRect();
  const cx = startX - rect.left - rect.width/2;
  const cy = startY - rect.top - rect.height/2;

  // 단순하게 중심 근처 클릭 시 층 회전
  if(Math.abs(cx)<150 && Math.abs(cy)<150){
    dragMode = "layer";
    selectedLayer = 2; // 예: 최상층
  } else {
    dragMode = "cube";
  }
  container.style.cursor = 'grabbing';
}

function onDrag(e){
  if(!isDragging) return;
  let clientX = e.clientX || e.touches[0].clientX;
  let clientY = e.clientY || e.touches[0].clientY;
  let dx = clientX - startX;
  let dy = clientY - startY;

  if(dragMode==="cube"){
    rotY += dx*0.5;
    rotX -= dy*0.5;
    container.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
  } else if(dragMode==="layer"){
    // 단순 드래그 방향으로 연속 회전
    if(Math.abs(dx) > 10){
      rotateLayer("y", selectedLayer, dx>0?1:-1);
      startX = clientX;
    }
    if(Math.abs(dy) > 10){
      rotateLayer("x", selectedLayer, dy>0?1:-1);
      startY = clientY;
    }
  }

  startX = clientX;
  startY = clientY;
}

function endDrag(){
  isDragging = false;
  container.style.cursor = 'grab';
}

document.addEventListener("mousedown", startDrag);
document.addEventListener("mousemove", onDrag);
document.addEventListener("mouseup", endDrag);
document.addEventListener("touchstart", startDrag);
document.addEventListener("touchmove", onDrag,{passive:false});
document.addEventListener("touchend", endDrag);

</script>
</body>
</html>
